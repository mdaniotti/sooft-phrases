import React, { useReducer, useEffect, useCallback, useMemo } from "react";
import useLocalStorage from "../hooks/useLocalStorage";
import {
  ACTIONS,
  PhrasesContext,
  PhrasesDataContext,
  PhrasesFilterContext,
  PhrasesActionsContext,
  phrasesReducer,
  type Phrase,
  type PhrasesState,
} from "./phrasesCore";

/**
 * Provider that manages the phrases state using useReducer
 * and automatically synchronizes with localStorage
 */
export const PhrasesProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const [persistedPhrases, setPersistedPhrases] = useLocalStorage<Phrase[]>(
    "phrases",
    []
  );

  const initialState: PhrasesState = {
    phrases: persistedPhrases,
    filter: "",
  };

  const [state, dispatch] = useReducer(phrasesReducer, initialState);

  // Sync with localStorage
  useEffect(() => {
    setPersistedPhrases(state.phrases);
  }, [state.phrases, setPersistedPhrases]);

  const addPhrase = useCallback((text: string) => {
    const newPhrase = {
      // TODO: Migrate to UUIDs or IDs generated by the backend
      id: Date.now() + Math.random(), // Use timestamp + random to generate unique IDs temporarily
      text: text.trim(),
      createdAt: new Date().toISOString(),
    };
    dispatch({ type: ACTIONS.ADD_PHRASE, payload: newPhrase });
    // TODO: When migrating to backend requests, consider useOptimistic for instant UI feedback
  }, []);

  const deletePhrase = useCallback((id: number | string) => {
    dispatch({ type: ACTIONS.DELETE_PHRASE, payload: id });
    // TODO: When migrating to backend requests, consider useOptimistic for instant UI feedback
  }, []);

  const setFilter = useCallback((filter: string) => {
    dispatch({ type: ACTIONS.SET_FILTER, payload: filter });
  }, []);

  // Separate memoized values for selective subscriptions
  const phrasesValue = useMemo(() => state.phrases, [state.phrases]);
  const filterValue = useMemo(() => state.filter, [state.filter]);
  
  const filterContextValue = useMemo(
    () => ({ filter: filterValue, setFilter }),
    [filterValue, setFilter]
  );

  const actionsContextValue = useMemo(
    () => ({ addPhrase, deletePhrase }),
    [addPhrase, deletePhrase]
  );

  // Main context value (for backward compatibility)
  const mainContextValue = useMemo(() => {
    return {
      phrases: phrasesValue,
      filter: filterValue,
      addPhrase,
      deletePhrase,
      setFilter,
    };
  }, [phrasesValue, filterValue, addPhrase, deletePhrase, setFilter]);

  return (
    <PhrasesContext.Provider value={mainContextValue}>
      <PhrasesDataContext.Provider value={phrasesValue}>
        <PhrasesFilterContext.Provider value={filterContextValue}>
          <PhrasesActionsContext.Provider value={actionsContextValue}>
            {children}
          </PhrasesActionsContext.Provider>
        </PhrasesFilterContext.Provider>
      </PhrasesDataContext.Provider>
    </PhrasesContext.Provider>
  );
};
